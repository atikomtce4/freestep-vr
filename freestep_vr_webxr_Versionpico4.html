<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FreeStep VR - Pico 4</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  #ui { position:fixed; left:10px; top:10px; z-index:20; color:#fff; }
  button { font-size:16px; padding:8px 10px; margin:2px; }
</style>
</head>
<body>

<div id="ui">
  <button id="btnConnect">Connect FreeStep</button>
  <span id="status">disconnected</span>
  <div>SPD: <span id="spd">0.00</span> m/s &nbsp; DIR: <span id="dir">0</span> &nbsp; LAT: <span id="lat">0</span></div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/webxr/VRButton.js';

const SERVICE_UUID = '12345678-1234-5678-1234-56789abcdef0';
const CHAR_UUID    = '12345678-1234-5678-1234-56789abcdef1';

let bleDevice = null;
let bleChar = null;
let connected = false;

const statusEl = document.getElementById('status');
const spdEl = document.getElementById('spd');
const dirEl = document.getElementById('dir');
const latEl = document.getElementById('lat');

let telemetry = { spd: 0.0, dir: 0, lat: 0 };

// -------------------- BLE --------------------
async function connectBLE() {
  try {
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ services: [SERVICE_UUID] }]
    });
    bleDevice = device;
    bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
    const server = await device.gatt.connect();
    const service = await server.getPrimaryService(SERVICE_UUID);
    bleChar = await service.getCharacteristic(CHAR_UUID);
    await bleChar.startNotifications();
    bleChar.addEventListener('characteristicvaluechanged', onNotify);
    connected = true;
    statusEl.textContent = 'connected';
  } catch (e) {
    statusEl.textContent = 'error';
    console.error(e);
  }
}

function onDisconnected() {
  connected = false;
  statusEl.textContent = 'disconnected';
}

function onNotify(ev) {
  try {
    const txt = new TextDecoder().decode(ev.target.value);
    const obj = JSON.parse(txt);
    telemetry.spd = parseFloat(obj.spd) || 0;
    telemetry.dir = parseInt(obj.dir) || 0;
    telemetry.lat = parseInt(obj.lat) || 0;
    spdEl.textContent = telemetry.spd.toFixed(2);
    dirEl.textContent = telemetry.dir;
    latEl.textContent = telemetry.lat;
  } catch(err) { console.warn('BLE JSON parse error', err); }
}

document.getElementById('btnConnect').addEventListener('click', connectBLE);

// -------------------- Three.js + WebXR --------------------
let camera, scene, renderer, playerGroup;
let lastTime = performance.now();
let smoothedSpeed = 0;
const smoothSpeedAlpha = 0.15;

init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x88c0ff);

  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 1000);

  playerGroup = new THREE.Group();
  playerGroup.position.set(0,1.6,0);
  playerGroup.add(camera);
  scene.add(playerGroup);

  // Ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x3a7d2b}));
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff,0x444444,1.2);
  scene.add(hemi);

  // Obstacles
  const boxGeo = new THREE.BoxGeometry(1,1,1);
  const boxMat = new THREE.MeshStandardMaterial({color:0xffcc00});
  for(let i=0;i<40;i++){
    const m = new THREE.Mesh(boxGeo, boxMat);
    m.position.set((Math.random()-0.5)*40,0.5,- (Math.random()*200+10));
    scene.add(m);
  }

  // Reticle
  const ringGeo = new THREE.RingGeometry(0.02,0.04,32);
  const ringMat = new THREE.MeshBasicMaterial({color:0xffffff, side:THREE.DoubleSide});
  const ret = new THREE.Mesh(ringGeo, ringMat);
  ret.position.set(0,0,-1);
  camera.add(ret);

  // Renderer + WebXR
  renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

function animate(){
  renderer.setAnimationLoop(render);
}

function render(){
  const now = performance.now();
  const dt = Math.min(0.05, (now-lastTime)/1000);
  lastTime = now;

  // Smooth speed
  const targetSpeed = telemetry.spd * telemetry.dir;
  smoothedSpeed += (targetSpeed-smoothedSpeed) * smoothSpeedAlpha;

  const strafe = (telemetry.lat||0)*(Math.abs(smoothedSpeed)*0.3);

  // Move playerGroup along camera forward
  const q = camera.quaternion;
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(q); forward.y=0; forward.normalize();
  const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();

  const move = forward.multiplyScalar(smoothedSpeed*dt).add(right.multiplyScalar(strafe*dt));
  playerGroup.position.add(move);

  renderer.render(scene, camera);
}
</script>
</body>
</html>
